'use strict';

function createDeferred() {
  const d = {};
  d.promise = new Promise((resolve, reject) => {
    d.resolve = resolve;
    d.reject = reject;
  });
  return d;
}

const SYMBOL_FINISHED = /*#__PURE__*/Symbol();
const SYMBOL_NEW_VALUE = /*#__PURE__*/Symbol();
/**
 * makePushPullAsyncIterableIterator
 *
 * The iterable will publish values until return or throw is called.
 * Afterwards it is in the completed state and cannot be used for publishing any further values.
 * It will handle back-pressure and keep pushed values until they are consumed by a source.
 */

function makePushPullAsyncIterableIterator() {
  let isRunning = true;
  const values = [];
  let newValueD = createDeferred();
  let finishedD = createDeferred();

  const asyncIterableIterator = async function* PushPullAsyncIterableIterator() {
    while (true) {
      if (values.length > 0) {
        yield values.shift();
      } else {
        const result = await Promise.race([newValueD.promise, finishedD.promise]);

        if (result === SYMBOL_FINISHED) {
          break;
        }

        if (result !== SYMBOL_NEW_VALUE) {
          throw result;
        }
      }
    }
  }();

  function pushValue(value) {
    if (isRunning === false) {
      // TODO: Should this throw?
      return;
    }

    values.push(value);
    newValueD.resolve(SYMBOL_NEW_VALUE);
    newValueD = createDeferred();
  } // We monkey patch the original generator for clean-up


  const originalReturn = asyncIterableIterator.return.bind(asyncIterableIterator);

  asyncIterableIterator.return = (...args) => {
    isRunning = false;
    finishedD.resolve(SYMBOL_FINISHED);
    return originalReturn(...args);
  };

  const originalThrow = asyncIterableIterator.throw.bind(asyncIterableIterator);

  asyncIterableIterator.throw = err => {
    isRunning = false;
    finishedD.resolve(err);
    return originalThrow(err);
  };

  return {
    pushValue,
    asyncIterableIterator
  };
}

const makeAsyncIterableIteratorFromSink = make => {
  const {
    pushValue,
    asyncIterableIterator
  } = makePushPullAsyncIterableIterator();
  const dispose = make({
    next: value => {
      pushValue(value);
    },
    complete: () => {
      asyncIterableIterator.return();
    },
    error: err => {
      asyncIterableIterator.throw(err);
    }
  });
  const originalReturn = asyncIterableIterator.return;
  let returnValue = undefined;

  asyncIterableIterator.return = () => {
    if (returnValue === undefined) {
      dispose();
      returnValue = originalReturn();
    }

    return returnValue;
  };

  return asyncIterableIterator;
};

function applyAsyncIterableIteratorToSink(asyncIterableIterator, sink) {
  const run = async () => {
    try {
      for await (const value of asyncIterableIterator) {
        sink.next(value);
      }

      sink.complete();
    } catch (err) {
      sink.error(err);
    }
  };

  run();
  return () => {
    asyncIterableIterator.return == null ? void 0 : asyncIterableIterator.return();
  };
}

function isAsyncIterable(input) {
  return typeof input === "object" && input !== null && ( // The AsyncGenerator check is for Safari on iOS which currently does not have
  // Symbol.asyncIterator implemented
  // That means every custom AsyncIterable must be built using a AsyncGeneratorFunction (async function * () {})
  input[Symbol.toStringTag] === "AsyncGenerator" || Symbol.asyncIterator && Symbol.asyncIterator in input);
}

exports.applyAsyncIterableIteratorToSink = applyAsyncIterableIteratorToSink;
exports.isAsyncIterable = isAsyncIterable;
exports.makeAsyncIterableIteratorFromSink = makeAsyncIterableIteratorFromSink;
exports.makePushPullAsyncIterableIterator = makePushPullAsyncIterableIterator;
//# sourceMappingURL=push-pull-async-iterable-iterator.cjs.development.js.map
